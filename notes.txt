C Notes

fflush to immediately display the contents of an output stream instead of buffering them and then writing it to an stdout or file (for immediate feedback)
printf and fprinf - former stdout, latter to a file or named output stream
* is pointer, & is address of * (e.g. *ptr = &a, menaing ptr now holds address of a) 
r w a for read, write and append, b to everything for binary
r+ read when file exists, w+ read and write, create file when file does not exist, if exist, truncate (delete) the contents, a+ read and append, same with w+ but at the end of the file
%s - string, %d - int, %f - float (%1.f -> up to 1 decimal), %c - char, $lf - double (up to 15 decimals)
For quotation marks: use escape sequence \ (\"string\" would be "string")
struct to create a structure, typedef to give alias to this structure (for e.g struct student {vars}; -> each time when we call this struct, it would be struct student s1; // with typedef sturct student {vars} Student; -> Student s1)
const before datatype ensures that no changes happen to input in function, still allows both const and non-const arguments in funcs
\r is Carrigae return char
strchr(given string, search char in string): can also be used like strchr(specified char, next to find char) to find the next char after the specified char in the string, also do (ptr+1, char) for char after ptr
static inside a function : retains the values until the program ends, retains in successive calls to funcs : for e.g. if static char buffer[50] = "Initial"; snprintf(buffer, sizeof(buffer), "Modify"), when the func is called first time, it will give Initial and Modify when called second time 
static outside a function will be limited to the file it exists
snprintf to format and store a series of chars into buffer, allows to specify max num of chars, snprintf(char *str, sizeof(str), format,..), if buffer size is small, data will be truncated
fprintf to display output at specified stream in a format (stderr, "format") to output as stderr
strncpy (target destination to be copied, source string to be copied, no of chars to copy from source)
strcasecmp(s1 ptr, s2 ptr) - to compare s1 and s2 ignoring cases, strncasecmp with no of chars from s1 to s2
strncat / strncpy (target destination to be added, source string to be added, no of chars to add from source)

libpng 
png_structp - pointer to png_struct, central, holds info about PNG file and state of PNG writing/reading process
png_infop - pointer to metadata of PNG file such as width, height, color type etc. also info about various chunks of information
png_create_read_struct(png lib version, error ptr, error handler, warn handler)
setjmp - when lib faces error, it wants to longjmp back to the routine, setjmp to save the current env for longjmp to use (need to use png ptr which is png_jmpbuf)

libjpeg
jpeg_decompress_struct - like png_struct, cinfo - instance of struct
jpeg_error_mgr - error handler struct, contains pointer, jerr is an instance of that struct 
cinfo.err is field of cinfo (address of jerr in assigned to this)
jpeg_create_decompress initializes the jpeg decompression object
jpeg_stdio_src makes decompression object read from file(&cinfo for struct, fp for file)
jpeg_read_header reads the header of JPEG which has basic info like width, height, color,
JSAMPLE - represents a single sample or pixel value,normally char
JSAMPROW - ptr to a row of samples, single scanline 
JSAMPARRAY - ptr to an array of rows, a 2D array where each element is a scanline 
alloc_sarray -memory management structure to allocated a 2D array of samples
j_common_ptr - generic pointer type for both compression and decompression
JPOOL_IMAGE - memory pool for allocation, will be freed when the decompression object is destroyed

SDL for Rendering Image
SDL_INIT_VIDEO - To initiate SDL and Video (Image)
SDL_CreateWindow(const char *title, pos x of window, pos y of window, width, height, flags like SDL_WINDOW_FULLSCREEEN, shown, hidden, resizable)
SDL_Renderer(window instance/ptr to struct, index (if -1 is passed, choose the first driver that supports the flags), SDL_RENDERER_ACCELERATED for hardware acceleration, software for software fallback, presentvsync, targettexture)
SDL_Surface stores the raw pixel data and bit info of image file
SDL_CreateTextureFromSurface creates texture from stored raw pixel surface data
SDL_Event to hold events of SDL instance
SDL_GetError() to show stderr with fprintf
SDL_FreeSurface - free the surface after using it
IMG_Init(Img flags) like IMG_INIT_JPG | IMG_INIT_PNG to initialize the image
IMG_SavePNG : Save the SDL surface as PNG file

Libsodium for Argon2
Common context in libsodium :  0 on success, -1 on failure and 1 if already started
sodium_init to initalize the lib, have context
crypto_pwhash_STRBYTES - 128, for storing the complete hashed password string with metadata, for storage and verification, /// there are also BYTES for when only raw hash output is needed, SALTBYTES for defining salt size to ensure unique hashes
crypto_pwhash_OPSLIMIT_* for time cost, MEMLIMIT_* for memory cost, can be choosen between INTERACTIVE, MODERATE, and SENSITIVE (low to high)
crypto_pwhash_str(output_hash, input_string, strlen(input), time cost, memory cost), have context
crypto_pwhash_str_verify(hashed_string, input_password, strlen(input_string)) to verify the hash. Has common context

zxcvbn library for password strength checker
ZxcMatch_t : struct of ZxcMatch(Begin begin, Length length, Entrpy entropy, MltEnpy multipart password, Type matching types like dict match, struct ZxcMatch *Next)
ZxcvbnMatch : main password matching func (password, user defined dict, info on matches), return the entropy in bits
ZxcvbnFreeInfo : matches data should be freed after func is done


Ideas on how to make password manager with steganography (Thought process)

I started this because it sounds fun. I got this idea from PirateSoftware where I saw a shorts on how he stored the passwords with funny images. I am bad at memorizing all the passwords. But what if images become my passwords to all the accounts that I have, I just need to store the images and won't have to memorize the passwords again.

It's not a good idea security wise to embed the passwords directly into image as attackers can directly extract the passwords from the image. Instead use the master password to encrypt the passwords for the accounts and embed the encrypted data into image. 

But how do user use the master image directly without the master password tho? What if they forgot the master password but they still have master image, I want them to be able to use master image as their master password as well.

We can also use the master image to encrypt the password by generating a unique fingerprint of hash from the image. We can do this by using certain attributes of the image like pixels, metadata or a combi of these. Then use this fingerprint to generate a key to re-encrypt the encrypted data again. 

This is like basically dual-key system. Make sure there are backups if both master password and master keys are lost. I think I will store the encrypted data in local file. I have to make sure that only the application can access the file. Might move onto database storage later. 